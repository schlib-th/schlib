/*
 * FontMetric.java
 *
 * Copyright 2014 by Thomas Hirsch, schlib@fahimu.de
 */

package de.fahimu.schlib.pdf;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import de.fahimu.schlib.app.App;
import de.fahimu.schlib.app.R;

/**
 * The {@code FontMetric} contains a font's metric, load from an Adobe Font Metrics file ({@code *.afm}).
 *
 * @author Thomas Hirsch, schlib@fahimu.de
 * @version 1.0, 01.09.2014
 * @since SchoolLibrary 1.0
 */
class FontMetric {

   private final int resId;

   private final int[] width = new int[256];

   private final int[][] adjust = new int[256][];

   /**
    * Creates a new FontMetric for font {@code resId}. An Adobe Font Metrics file ({@code *.afm}) and
    * the Adobe Glyph List file ({@code glyphlist.txt}) must be installed in {@code res/raw/}.
    *
    * @param resId
    *       the resource identifier to open, as generated by the appt tool.
    */
   FontMetric(int resId) { this.resId = resId; }

   private LineNumberReader openFile(int resId, Charset charset) {
      InputStream is = App.getInstance().getResources().openRawResource(resId);
      return new LineNumberReader(new InputStreamReader(is, charset));
   }

   private Map<String,Character> loadGlyphlist() throws IOException {
      Map<String,Character> glyphMap = new HashMap<>(256);
      try (LineNumberReader lnr = openFile(R.raw.glyphlist, Charset.forName("US-ASCII"))) {
         String line = lnr.readLine();
         while (line != null && line.startsWith("#")) {
            line = lnr.readLine();
         }
         while (line != null && !line.startsWith("#")) {
            int semicolon = line.indexOf(';');
            String glyphname = line.substring(0, semicolon);
            long c = Integer.parseInt(line.substring(semicolon + 1, semicolon + 5), 16);
            if ((c >= 0x20 && c <= 0x7E) || (c >= 0xA0 && c <= 0xFF)) {
               glyphMap.put(glyphname, (char) c);
            }
            line = lnr.readLine();
         }
         return glyphMap;
      }
   }

   private static final Pattern WX = Pattern.compile(".*WX\\s([0-9]+)\\s;.*");
   private static final Pattern GN = Pattern.compile(".*N\\s([A-Za-z]+)\\s;.*");

   private void loadCharMetrics(LineNumberReader lnr, Map<String,Character> glyphMap) throws IOException {
      String line = lnr.readLine();
      while (!line.startsWith("StartCharMetrics")) {
         line = lnr.readLine();
      }
      int nLine = Integer.parseInt(line.substring(line.indexOf(' ') + 1));
      while (nLine-- > 0) {
         line = lnr.readLine();
         Matcher wx = WX.matcher(line), gn = GN.matcher(line);
         if (wx.matches() && gn.matches() && glyphMap.containsKey(gn.group(1))) {
            width[(int) glyphMap.get(gn.group(1))] = Integer.parseInt(wx.group(1));
         }
      }
   }

   private static final Pattern KPX = Pattern.compile("KPX\\s([A-Za-z]+)\\s([A-Za-z]+)\\s-([0-9]+)");

   private void loadKernPairs(LineNumberReader lnr, Map<String,Character> glyphMap) throws IOException {
      String line = lnr.readLine();
      while (!line.startsWith("StartKernPairs")) {
         line = lnr.readLine();
      }
      int nLine = Integer.parseInt(line.substring(line.indexOf(' ') + 1));
      while (nLine-- > 0) {
         Matcher kpx = KPX.matcher(lnr.readLine());
         if (kpx.matches() && glyphMap.containsKey(kpx.group(1)) && glyphMap.containsKey(kpx.group(2))) {
            int lft = (int) glyphMap.get(kpx.group(1)), rgt = (int) glyphMap.get(kpx.group(2));
            if (adjust[lft] == null) {
               adjust[lft] = new int[256];        // create subarray only when necessary
            }
            adjust[lft][rgt] = Integer.parseInt(kpx.group(3));
         }
      }
   }

   /**
    * Initialize FontMetric by loading {@code *.afm} file.
    *
    * @return this FontMetric object.
    */
   FontMetric init() {
      try {
         Map<String,Character> glyphMap = loadGlyphlist();
         try (LineNumberReader lnr = openFile(resId, Charset.forName("US-ASCII"))) {
            loadCharMetrics(lnr, glyphMap);
            loadKernPairs(lnr, glyphMap);
         }
      } catch (IOException ioe) {
         Arrays.fill(width, 1000);
         Arrays.fill(adjust, null);
      }
      return this;
   }

   /**
    * Returns the width of the specified character as defined by the {@code CharMetrics} section in the {@code .afm}
    * file.
    *
    * @param c
    *       the character.
    * @return the width of the specified character.
    */
   int getWidth(char c) { return width[(int) c]; }

   /**
    * Returns the horizontal adjustment of the character pair {@code (lft, rgt)} as defined by the {@code KernPairs}
    * section in the {@code .afm} file.
    *
    * @param lft
    *       the left character.
    * @param rgt
    *       the right character.
    * @return the horizontal adjustment of the character pair.
    */
   int getAdjustment(char lft, char rgt) {
      return (adjust[(int) lft] == null) ? 0 : adjust[(int) lft][(int) rgt];
   }

}