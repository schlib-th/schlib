/*
 * App.java
 *
 * Copyright 2015 by Thomas Hirsch, schlib@fahimu.de
 */

package de.fahimu.android.app;

import android.content.res.Resources;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.support.annotation.ColorInt;
import android.support.annotation.ColorRes;
import android.support.annotation.IdRes;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RawRes;
import android.support.annotation.StringRes;
import android.support.v4.content.ContextCompat;
import android.view.View;


import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Locale;
import java.util.TimeZone;

/**
 * The object returned by {@link android.content.Context#getApplicationContext()}.
 *
 * @author Thomas Hirsch, schlib@fahimu.de
 * @version 1.0, 01.09.2015
 * @since SchoolLibrary 1.0
 */
public abstract class App extends android.app.Application {

   @Nullable
   private static App singleton;

   @NonNull
   public static App getInstance() {
      if (singleton == null) {
         throw new IllegalStateException("getInstance() called before onCreate()");
      } else {
         return singleton;
      }
   }

   @Override
   public void onCreate() {
      super.onCreate();
      singleton = this;
      Log.d("App " + singleton.getClass() + " (" + getName() + ") created");
   }

   @NonNull
   public abstract String getName();

   @NonNull
   protected abstract SoundPlayer getSoundPlayer();

   /**
    * Play the specified sound file.
    *
    * @param resId
    *       the name of the sound file without its extension.
    */
   public static void playSound(@RawRes int resId) {
      getInstance().getSoundPlayer().play(resId);
   }

   /* ============================================================================================================== */

   @Nullable
   private static SQLiteDatabase database;

   @NonNull
   public static synchronized SQLiteDatabase getDb() {
      if (database == null) {
         database = getInstance().getOpenHelper().getWritableDatabase();
      }
      return database;
   }

   protected abstract SQLiteOpenHelper getOpenHelper();

   /* ============================================================================================================== */

   /**
    * Returns a color value in the form {@code 0xAARRGGBB} associated with the specified color resource ID.
    *
    * @param colorResId
    *       the color resource ID, as generated by the aapt tool.
    * @return a color value in the form {@code 0xAARRGGBB} associated with the specified color resource ID.
    */
   @ColorInt
   public static int getColorFromRes(@ColorRes int colorResId) {
      return ContextCompat.getColor(getInstance(), colorResId);
   }

   /**
    * Returns the number of screen pixels for the specified density independent pixels value.
    *
    * @param dp
    *       the density independent pixels value.
    * @return the number of screen pixels for the specified density independent pixels value.
    */
   public static int dpToPx(float dp) {
      return Math.round(dp * Resources.getSystem().getDisplayMetrics().density);
   }

   /**
    * Returns a localized formatted string from the application's package's
    * default string table, substituting the format arguments as defined in
    * {@link java.util.Formatter} and {@link java.lang.String#format}.
    *
    * @param resId
    *       resource id for the format string
    * @param formatArgs
    *       the format arguments that will be used for substitution.
    * @return a localized formatted string.
    */
   @NonNull
   public static String getStr(@StringRes int resId, Object... formatArgs) {
      return getInstance().getString(resId, formatArgs);
   }

   /**
    * Returns a {@link Locale#US} localized formatted string,
    * substituting the format arguments as defined in
    * {@link java.util.Formatter} and {@link java.lang.String#format}.
    *
    * @param format
    *       the format string (see {@link java.util.Formatter#format}).
    * @param formatArgs
    *       the format arguments that will be used for substitution.
    * @return the formatted string.
    */
   @NonNull
   public static String format(String format, Object... formatArgs) {
      return String.format(Locale.US, format, formatArgs);
   }

   /**
    * Returns the child view with the specified {@code resId}.
    * If there is no such child view defined, or if the view cannot be cast to the specified {@code type},
    * an {@link ClassCastException} will be thrown.
    *
    * @param parent
    *       the parent view where to search.
    * @param type
    *       the type of the requested view.
    * @param resId
    *       the id attribute of the view from the XML file.
    * @return the child view with the specified {@code resId}.
    *
    * @throws ClassCastException
    *       if there is no such child view defined.
    */
   @NonNull
   public static <V extends View> V findView(@NonNull View parent, @NonNull Class<V> type, @IdRes int resId) {
      View child = parent.findViewById(resId);
      if (child == null) { throw new ClassCastException("resource not found"); }
      return type.cast(child);
   }

   /* ============================================================================================================== */

   /**
    * Returns the current POSIX time.
    *
    * @return the current POSIX time.
    *
    * @see <a href="https://en.wikipedia.org/wiki/Unix_time">POSIX time</a>
    */
   public static long posixTime() {
      return System.currentTimeMillis() / 1000;
   }

   /**
    * Returns the number of days since 1.1.1970 in the {@link TimeZone#getDefault() default} timezone.
    *
    * @return the number of days since 1.1.1970 in the {@link TimeZone#getDefault() default} timezone.
    *
    * @see <a href="https://en.wikipedia.org/wiki/Unix_time">POSIX time</a>
    */
   public static long localDate() {
      Calendar calendar = new GregorianCalendar();
      long diff = calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET);
      return (calendar.getTimeInMillis() + diff) / 1000 / 86400;
   }

   /**
    * Returns the POSIX time of the begin of current day in the {@link TimeZone#getDefault() default} timezone.
    *
    * @return the POSIX time of the begin of current day in the {@link TimeZone#getDefault() default} timezone.
    */
   public static long beginOfDay() {
      Calendar calendar = new GregorianCalendar();
      calendar.set(Calendar.HOUR_OF_DAY, 0);
      calendar.set(Calendar.MINUTE, 0);
      calendar.set(Calendar.SECOND, 0);
      calendar.set(Calendar.MILLISECOND, 0);
      return calendar.getTimeInMillis() / 1000;
   }

   private static final HashMap<String,SimpleDateFormat> UTC   = new HashMap<>();
   private static final HashMap<String,SimpleDateFormat> LOCAL = new HashMap<>();

   /**
    * Returns the specified {@code posixTime} formatted according to the specified {@code format}.
    * If {@code utc} is {@code true}, {@link TimeZone#getTimeZone getTimeZone("UTC")} will be used,
    * else the {@link TimeZone#getDefault() default} timezone.
    *
    * @param format
    *       the pattern string.
    * @param utc
    *       if {@code true}, {@code getTimeZone("UTC")} will be used, else the default timezone.
    * @param posixTime
    *       the POSIX time to format.
    * @return the specified {@code posixTime} formatted according to the specified {@code format}.
    *
    * @see <a href="https://en.wikipedia.org/wiki/Unix_time">POSIX time</a>
    */
   @NonNull
   public static synchronized String formatDate(@NonNull String format, boolean utc, long posixTime) {
      SimpleDateFormat sdf = (utc ? UTC : LOCAL).get(format);
      if (sdf == null) {
         sdf = new SimpleDateFormat(format, Locale.US);
         sdf.setCalendar(new GregorianCalendar(utc ? TimeZone.getTimeZone("UTC") : TimeZone.getDefault()));
         (utc ? UTC : LOCAL).put(format, sdf);
      }
      return sdf.format(new Date(posixTime * 1000));
   }

   public static String formatDate(@StringRes int resId, boolean utc, long posixTime) {
      return formatDate(getStr(resId), utc, posixTime);
   }

}